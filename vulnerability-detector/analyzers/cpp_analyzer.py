# C++ specific analyzer
"""
C++-specific vulnerability analyzer
"""

import re
from typing import List, Dict, Any
from .base_analyzer import BaseAnalyzer

class CppAnalyzer(BaseAnalyzer):
    """Analyzer for C++ code vulnerabilities"""
    
    def __init__(self):
        super().__init__("cpp")
        self.patterns = {
            "buffer_overflow": [
                r"strcpy\s*\(",
                r"strcat\s*\(",
                r"gets\s*\(",
                r"sprintf\s*\(",
            ],
            "memory_leak": [
                r"malloc\s*\(",
                r"new\s+\w+",
                r"calloc\s*\(",
            ],
            "format_string": [
                r"printf\s*\(\s*[^,]*\s*\)",
                r"fprintf\s*\(\s*[^,]*\s*\)",
            ],
            "integer_overflow": [
                r"\w+\s*\+\s*\w+\s*<\s*\w+",
                r"\w+\s*\*\s*\w+",
            ]
        }
    
    def analyze(self, code: str, file_path: str) -> List[Dict[str, Any]]:
        """Analyze C++ code for vulnerabilities"""
        vulnerabilities = []
        lines = code.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            for vuln_type, patterns in self.patterns.items():
                for pattern in patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        vuln = self._create_vulnerability_report(
                            vuln_type=vuln_type,
                            line_number=line_num,
                            severity="HIGH" if vuln_type == "buffer_overflow" else "MEDIUM",
                            description=f"Potential {vuln_type.replace('_', ' ')} vulnerability detected"
                        )
                        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def get_supported_patterns(self) -> List[str]:
        """Get list of supported vulnerability patterns"""
        return list(self.patterns.keys())
