# Java specific analyzer
"""
Java-specific vulnerability analyzer
"""

import re
from typing import List, Dict, Any
from .base_analyzer import BaseAnalyzer

class JavaAnalyzer(BaseAnalyzer):
    """Analyzer for Java code vulnerabilities"""
    
    def __init__(self):
        super().__init__("java")
        self.patterns = {
            "sql_injection": [
                r"Statement\.executeQuery\s*\(\s*.*\+.*\)",
                r"prepareStatement\s*\(\s*.*\+.*\)",
            ],
            "xss": [
                r"response\.getWriter\(\)\.write\s*\(.*\+",
                r"out\.println\s*\(.*\+",
            ],
            "path_traversal": [
                r"new\s+File\s*\(\s*.*\+.*\)",
                r"\.\.\/",
            ],
            "deserialization": [
                r"ObjectInputStream\s*\(",
                r"readObject\s*\(\)",
            ]
        }
    
    def analyze(self, code: str, file_path: str) -> List[Dict[str, Any]]:
        """Analyze Java code for vulnerabilities"""
        vulnerabilities = []
        lines = code.split('\n')
        
        for line_num, line in enumerate(lines, 1):
            for vuln_type, patterns in self.patterns.items():
                for pattern in patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        vuln = self._create_vulnerability_report(
                            vuln_type=vuln_type,
                            line_number=line_num,
                            severity="HIGH" if vuln_type in ["sql_injection", "deserialization"] else "MEDIUM",
                            description=f"Potential {vuln_type.replace('_', ' ')} vulnerability detected"
                        )
                        vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def get_supported_patterns(self) -> List[str]:
        """Get list of supported vulnerability patterns"""
        return list(self.patterns.keys())
