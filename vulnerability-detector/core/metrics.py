# Accuracy calculations
"""
Metrics calculation module for evaluating detection accuracy
"""

from typing import List, Dict, Any, Tuple

class AccuracyMetrics:
    """Calculate accuracy metrics for vulnerability detection"""
    
    def __init__(self):
        self.true_positives = 0
        self.false_positives = 0
        self.true_negatives = 0
        self.false_negatives = 0
    
    def calculate_metrics(self, detected_vulnerabilities: List[Dict[str, Any]], 
                         ground_truth: List[Dict[str, Any]]) -> Dict[str, float]:
        """Calculate accuracy metrics comparing detected vs ground truth"""
        
        # Reset counters
        self.true_positives = 0
        self.false_positives = 0
        self.false_negatives = 0
        
        # Convert to sets for easier comparison
        detected_set = self._vulnerabilities_to_set(detected_vulnerabilities)
        truth_set = self._vulnerabilities_to_set(ground_truth)
        
        # Calculate metrics
        self.true_positives = len(detected_set.intersection(truth_set))
        self.false_positives = len(detected_set - truth_set)
        self.false_negatives = len(truth_set - detected_set)
        
        # Calculate derived metrics
        precision = self._calculate_precision()
        recall = self._calculate_recall()
        f1_score = self._calculate_f1_score(precision, recall)
        accuracy = self._calculate_accuracy()
        
        return {
            "precision": precision,
            "recall": recall,
            "f1_score": f1_score,
            "accuracy": accuracy,
            "true_positives": self.true_positives,
            "false_positives": self.false_positives,
            "false_negatives": self.false_negatives
        }
    
    def _vulnerabilities_to_set(self, vulnerabilities: List[Dict[str, Any]]) -> set:
        """Convert vulnerability list to set for comparison"""
        return set(
            (vuln.get('type', ''), vuln.get('line', 0), vuln.get('severity', ''))
            for vuln in vulnerabilities
        )
    
    def _calculate_precision(self) -> float:
        """Calculate precision: TP / (TP + FP)"""
        if self.true_positives + self.false_positives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_positives)
    
    def _calculate_recall(self) -> float:
        """Calculate recall: TP / (TP + FN)"""
        if self.true_positives + self.false_negatives == 0:
            return 0.0
        return self.true_positives / (self.true_positives + self.false_negatives)
    
    def _calculate_f1_score(self, precision: float, recall: float) -> float:
        """Calculate F1 score: 2 * (precision * recall) / (precision + recall)"""
        if precision + recall == 0:
            return 0.0
        return 2 * (precision * recall) / (precision + recall)
    
    def _calculate_accuracy(self) -> float:
        """Calculate accuracy: (TP + TN) / (TP + TN + FP + FN)"""
        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives
        if total == 0:
            return 0.0
        return (self.true_positives + self.true_negatives) / total
    
    def calculate_severity_distribution(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
        """Calculate distribution of vulnerabilities by severity"""
        distribution = {"HIGH": 0, "MEDIUM": 0, "LOW": 0}
        
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'LOW')
            if severity in distribution:
                distribution[severity] += 1
        
        return distribution
    
    def calculate_language_distribution(self, vulnerabilities: List[Dict[str, Any]]) -> Dict[str, int]:
        """Calculate distribution of vulnerabilities by programming language"""
        distribution = {}
        
        for vuln in vulnerabilities:
            language = vuln.get('language', 'Unknown')
            distribution[language] = distribution.get(language, 0) + 1
        
        return distribution
