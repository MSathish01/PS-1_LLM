"""
Streamlit web interface for the vulnerability detection tool
"""
import streamlit as st
import pandas as pd
import plotly.express as px
from pathlib import Path
import tempfile
import os

from core.scanner import VulnerabilityScanner
from core.reporter import VulnerabilityReporter
from config.settings import SUPPORTED_LANGUAGES

class WebInterface:
    """
    Streamlit-based web interface for vulnerability scanning
    """
    
    def __init__(self):
        self.scanner = VulnerabilityScanner()
        self.reporter = VulnerabilityReporter()
        
    def run(self):
        """Main application interface"""
        st.set_page_config(
            page_title="AI Vulnerability Scanner",
            page_icon="ğŸ”’",
            layout="wide"
        )
        
        st.title("ğŸ”’ AI-Powered Vulnerability Detection Tool")
        st.markdown("**Detect security vulnerabilities in source code using AI and static analysis**")
        
        # Sidebar configuration
        st.sidebar.header("Configuration")
        use_llm = st.sidebar.checkbox("Enable LLM Analysis", value=True)
        llm_provider = st.sidebar.selectbox("LLM Provider", ["openai", "anthropic"])
        startup_name = st.sidebar.text_input("Startup Name", value="VulnDetector")
        
        # Main interface tabs
        tab1, tab2, tab3 = st.tabs(["ğŸ“ File/Directory Scan", "ğŸ“Š Results Dashboard", "ğŸ“‹ Reports"])
        
        with tab1:
            self._render_scan_interface(use_llm, llm_provider)
        
        with tab2:
            self._render_dashboard()
        
        with tab3:
            self._render_reports(startup_name)
    
    def _render_scan_interface(self, use_llm: bool, llm_provider: str):
        """Render the main scanning interface"""
        st.header("Scan Files or Directory")
        
        # Scan type selection
        scan_type = st.radio("Select scan type:", ["Single File", "Directory", "Multiple Files"])
        
        if scan_type == "Single File":
            self._render_single_file_scan(use_llm, llm_provider)
        elif scan_type == "Directory":
            self._render_directory_scan(use_llm, llm_provider)
        else:
            self._render_multiple_files_scan(use_llm, llm_provider)
    
    def _render_single_file_scan(self, use_llm: bool, llm_provider: str):
        """Interface for single file scanning"""
        uploaded_file = st.file_uploader(
            "Choose a source code file",
            type=list(SUPPORTED_LANGUAGES.keys())
        )
        
        if uploaded_file is not None:
            # Save uploaded file temporarily
            with tempfile.NamedTemporaryFile(delete=False, suffix=Path(uploaded_file.name).suffix) as tmp_file:
                tmp_file.write(uploaded_file.getvalue())
                tmp_file_path = tmp_file.name
            
            # Display file info
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Filename", uploaded_file.name)
            with col2:
                st.metric("File Size", f"{uploaded_file.size} bytes")
            with col3:
                language = SUPPORTED_LANGUAGES.get(Path(uploaded_file.name).suffix, "Unknown")
                st.metric("Language", language)
            
            # Scan button
            if st.button("ğŸ” Start Vulnerability Scan", type="primary"):
                with st.spinner("Analyzing code for vulnerabilities..."):
                    # Configure scanner
                    scanner = VulnerabilityScanner(use_llm=use_llm, llm_provider=llm_provider)
                    
                    # Perform scan
                    results = scanner.scan_file(tmp_file_path)
                    
                    # Store results in session state
                    st.session_state['scan_results'] = results
                    
                    # Display results
                    self._display_scan_results(results)
            
            # Cleanup
            if 'tmp_file_path' in locals():
                try:
                    os.unlink(tmp_file_path)
                except Exception:
                    pass
    
    def _render_directory_scan(self, use_llm: bool, llm_provider: str):
        """Interface for directory scanning"""
        st.info("ğŸ“ Directory scanning requires local file system access. Enter the path to scan:")
        
        directory_path = st.text_input("Directory Path:", placeholder="/path/to/source/code")
        recursive = st.checkbox("Scan subdirectories recursively", value=True)
        
        if directory_path and st.button("ğŸ” Start Directory Scan", type="primary"):
            if not Path(directory_path).exists():
                st.error("Directory path does not exist!")
                return
            
            with st.spinner(f"Scanning directory: {directory_path}"):
                scanner = VulnerabilityScanner(use_llm=use_llm, llm_provider=llm_provider)
                results = scanner.scan_directory(directory_path, recursive=recursive)
                
                st.session_state['scan_results'] = results
                self._display_directory_results(results)
    
    def _render_multiple_files_scan(self, use_llm: bool, llm_provider: str):
        """Interface for multiple file scanning"""
        uploaded_files = st.file_uploader(
            "Choose multiple source code files",
            type=list(SUPPORTED_LANGUAGES.keys()),
            accept_multiple_files=True
        )
        
        if uploaded_files:
            st.write(f"Selected {len(uploaded_files)} files:")
            for file in uploaded_files:
                st.write(f"- {file.name} ({file.size} bytes)")
            
            if st.button("ğŸ” Scan All Files", type="primary"):
                scanner = VulnerabilityScanner(use_llm=use_llm, llm_provider=llm_provider)
                all_results = []
                
                progress_bar = st.progress(0)
                for i, uploaded_file in enumerate(uploaded_files):
                    # Save file temporarily
                    with tempfile.NamedTemporaryFile(delete=False, suffix=Path(uploaded_file.name).suffix) as tmp_file:
                        tmp_file.write(uploaded_file.getvalue())
                        tmp_file_path = tmp_file.name
                    
                    # Scan file
                    result = scanner.scan_file(tmp_file_path)
                    all_results.append(result)
                    
                    # Update progress
                    progress_bar.progress((i + 1) / len(uploaded_files))
                    
                    # Cleanup
                    try:
                        os.unlink(tmp_file_path)
                    except Exception:
                        pass
                
                # Create combined results
                combined_results = {
                    'scan_type': 'multiple_files',
                    'files_scanned': len(all_results),
                    'file_results': all_results,
                    'total_vulnerabilities': sum(r.get('vulnerability_count', 0) for r in all_results)
                }
                
                st.session_state['scan_results'] = combined_results
                self._display_directory_results(combined_results)
    
    def _display_scan_results(self, results: dict):
        """Display results for single file scan"""
        if results.get('status') == 'error':
            st.error(f"Scan failed: {results.get('error')}")
            return
        
        vulnerabilities = results.get('vulnerabilities', [])
        
        # Results summary
        st.subheader("ğŸ“Š Scan Results")
        
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Vulnerabilities Found", len(vulnerabilities))
        with col2:
            st.metric("Risk Score", f"{results.get('risk_score', 0):.2f}")
        with col3:
            st.metric("Lines of Code", results.get('lines_of_code', 0))
        with col4:
            st.metric("Language", results.get('language', 'Unknown'))
        
        if vulnerabilities:
            # Severity breakdown
            severity_counts = {}
            for vuln in vulnerabilities:
                severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1
            
            # Severity chart
            fig = px.pie(
                values=list(severity_counts.values()),
                names=list(severity_counts.keys()),
                title="Vulnerabilities by Severity"
            )
            st.plotly_chart(fig, use_container_width=True)
            
            # Detailed vulnerability list
            st.subheader("ğŸš¨ Detected Vulnerabilities")
            
            for i, vuln in enumerate(vulnerabilities, 1):
                with st.expander(f"{i}. {vuln.vulnerability_type} (Line {vuln.line_number}) - {vuln.severity}"):
                    col1, col2 = st.columns([2, 1])
                    
                    with col1:
                        st.write(f"**Description:** {vuln.description}")
                        st.write(f"**Mitigation:** {vuln.mitigation}")
                        st.code(vuln.code_line, language=results.get('language', ''))
                    
                    with col2:
                        st.write(f"**CWE ID:** {vuln.cwe_id}")
                        st.write(f"**Confidence:** {vuln.confidence:.2f}")
                        st.write(f"**Severity:** {vuln.severity}")
        else:
            st.success("ğŸ‰ No vulnerabilities detected!")
    
    def _display_directory_results(self, results: dict):
        """Display results for directory or multiple file scan"""
        st.subheader("ğŸ“Š Scan Summary")
        
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("Files Scanned", results.get('files_scanned', 0))
        with col2:
            st.metric("Total Vulnerabilities", results.get('total_vulnerabilities', 0))
        with col3:
            avg_risk = results.get('average_risk_score', 0)
            st.metric("Average Risk Score", f"{avg_risk:.2f}")
        with col4:
            high_risk_files = len([f for f in results.get('file_results', []) if f.get('risk_score', 0) > 0.7])
            st.metric("High Risk Files", high_risk_files)
        
        # File-wise breakdown
        file_results = results.get('file_results', [])
        if file_results:
            # Create DataFrame for file analysis
            file_data = []
            for file_result in file_results:
                if file_result.get('status') == 'completed':
                    file_data.append({
                        'Filename': Path(file_result['filepath']).name,
                        'Language': file_result.get('language', 'Unknown'),
                        'Vulnerabilities': file_result.get('vulnerability_count', 0),
                        'Risk Score': f"{file_result.get('risk_score', 0):.2f}",
                        'Lines of Code': file_result.get('lines_of_code', 0)
                    })
            
            if file_data:
                df = pd.DataFrame(file_data)
                st.subheader("ğŸ“ File Analysis")
                st.dataframe(df, use_container_width=True)
                
                # Risk score distribution
                risk_scores = [float(row['Risk Score']) for row in file_data]
                fig = px.histogram(x=risk_scores, title="Risk Score Distribution", nbins=20)
                st.plotly_chart(fig, use_container_width=True)
    
    def _render_dashboard(self):
        """Render the results dashboard"""
        st.header("ğŸ“Š Results Dashboard")
        
        if 'scan_results' not in st.session_state:
            st.info("No scan results available. Please run a scan first.")
            return
        
        results = st.session_state['scan_results']
        
        # Dashboard content based on scan type
        if 'file_results' in results:
            self._render_directory_dashboard(results)
        else:
            self._render_single_file_dashboard(results)
    
    def _render_directory_dashboard(self, results: dict):
        """Dashboard for directory scan results"""
        file_results = results.get('file_results', [])
        
        # Overall statistics
        total_files = len(file_results)
        completed_files = len([f for f in file_results if f.get('status') == 'completed'])
        total_vulnerabilities = results.get('total_vulnerabilities', 0)
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("Total Files", total_files)
        with col2:
            st.metric("Successfully Analyzed", completed_files)
        with col3:
            st.metric("Total Vulnerabilities", total_vulnerabilities)
        
        if completed_files == 0:
            st.warning("No files were successfully analyzed.")
            return
        
        # Language distribution
        language_counts = {}
        vulnerability_by_language = {}
        
        for file_result in file_results:
            if file_result.get('status') == 'completed':
                language = file_result.get('language', 'Unknown')
                vuln_count = file_result.get('vulnerability_count', 0)
                
                language_counts[language] = language_counts.get(language, 0) + 1
                vulnerability_by_language[language] = vulnerability_by_language.get(language, 0) + vuln_count
        
        # Language charts
        col1, col2 = st.columns(2)
        
        with col1:
            fig1 = px.pie(values=list(language_counts.values()), names=list(language_counts.keys()),
                         title="Files by Language")
            st.plotly_chart(fig1, use_container_width=True)
        
        with col2:
            if any(vulnerability_by_language.values()):
                fig2 = px.bar(x=list(vulnerability_by_language.keys()), y=list(vulnerability_by_language.values()),
                             title="Vulnerabilities by Language")
                st.plotly_chart(fig2, use_container_width=True)
        
        # Top risky files
        risky_files = sorted(
            [f for f in file_results if f.get('status') == 'completed'],
            key=lambda x: x.get('risk_score', 0),
            reverse=True
        )[:10]
        
        if risky_files:
            st.subheader("ğŸš¨ Top 10 Risky Files")
            risky_data = []
            for file_result in risky_files:
                risky_data.append({
                    'Filename': Path(file_result['filepath']).name,
                    'Risk Score': f"{file_result.get('risk_score', 0):.2f}",
                    'Vulnerabilities': file_result.get('vulnerability_count', 0),
                    'Language': file_result.get('language', 'Unknown')
                })
            
            st.dataframe(pd.DataFrame(risky_data), use_container_width=True)
    
    def _render_single_file_dashboard(self, results: dict):
        """Dashboard for single file scan results"""
        vulnerabilities = results.get('vulnerabilities', [])
        
        if not vulnerabilities:
            st.info("No vulnerabilities found in this file.")
            return
        
        # Vulnerability type analysis
        type_counts = {}
        severity_counts = {}
        
        for vuln in vulnerabilities:
            type_counts[vuln.vulnerability_type] = type_counts.get(vuln.vulnerability_type, 0) + 1
            severity_counts[vuln.severity] = severity_counts.get(vuln.severity, 0) + 1
        
        col1, col2 = st.columns(2)
        
        with col1:
            fig1 = px.bar(x=list(type_counts.keys()), y=list(type_counts.values()),
                         title="Vulnerabilities by Type")
            fig1.update_xaxis(tickangle=45)
            st.plotly_chart(fig1, use_container_width=True)
        
        with col2:
            fig2 = px.pie(values=list(severity_counts.values()), names=list(severity_counts.keys()),
                         title="Vulnerabilities by Severity")
            st.plotly_chart(fig2, use_container_width=True)
        
        # Vulnerability timeline (by line number)
        vuln_lines = [vuln.line_number for vuln in vulnerabilities]
        fig3 = px.scatter(x=vuln_lines, y=[1] * len(vuln_lines), 
                         color=[vuln.severity for vuln in vulnerabilities],
                         title="Vulnerability Distribution by Line Number")
        st.plotly_chart(fig3, use_container_width=True)
    
    def _render_reports(self, startup_name: str):
        """Render the reports section"""
        st.header("ğŸ“‹ Generate Reports")
        
        if 'scan_results' not in st.session_state:
            st.info("No scan results available. Please run a scan first.")
            return
        
        results = st.session_state['scan_results']
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("ğŸ“Š Generate Excel Report"):
                with st.spinner("Generating Excel report..."):
                    excel_path = self.reporter.generate_excel_report(results, startup_name)
                    st.success(f"Excel report generated: {Path(excel_path).name}")
                    
                    # Provide download link
                    with open(excel_path, 'rb') as f:
                        st.download_button(
                            label="â¬‡ï¸ Download Excel Report",
                            data=f.read(),
                            file_name=Path(excel_path).name,
                            mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        )
        
        with col2:
            if st.button("ğŸ“„ Generate JSON Report"):
                with st.spinner("Generating JSON report..."):
                    json_path = self.reporter.generate_json_report(results, startup_name)
                    st.success(f"JSON report generated: {Path(json_path).name}")
                    
                    with open(json_path, 'r') as f:
                        st.download_button(
                            label="â¬‡ï¸ Download JSON Report",
                            data=f.read(),
                            file_name=Path(json_path).name,
                            mime="application/json"
                        )
        
        with col3:
            if st.button("ğŸŒ Generate HTML Report"):
                with st.spinner("Generating HTML report..."):
                    html_path = self.reporter.generate_html_report(results, startup_name)
                    st.success(f"HTML report generated: {Path(html_path).name}")
                    
                    with open(html_path, 'r', encoding='utf-8') as f:
                        st.download_button(
                            label="â¬‡ï¸ Download HTML Report",
                            data=f.read(),
                            file_name=Path(html_path).name,
                            mime="text/html"
                        )
        
        # Preview latest results
        st.subheader("ğŸ“‹ Results Preview")
        
        if 'file_results' in results:
            total_files = results.get('files_scanned', 0)
            total_vulns = results.get('total_vulnerabilities', 0)
            st.write(f"**Files Scanned:** {total_files}")
            st.write(f"**Total Vulnerabilities:** {total_vulns}")
        else:
            vuln_count = results.get('vulnerability_count', 0)
            risk_score = results.get('risk_score', 0)
            st.write(f"**Vulnerabilities Found:** {vuln_count}")
            st.write(f"**Risk Score:** {risk_score:.2f}")

def main():
    """Main application entry point"""
    interface = WebInterface()
    interface.run()

if __name__ == "__main__":
    main()
